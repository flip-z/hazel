package hazel

import (
	"crypto/sha1"
	"encoding/hex"
	"fmt"
	"os"
	"os/exec"
	"path/filepath"
	"sort"
	"strings"
	"time"
)

type TrackedProject struct {
	Key         string
	Name        string
	RepoPath    string
	StorageRoot string
	RepoSlug    string
}

type Nexus struct {
	Root            string
	ProjectsRootDir string
	Projects        []TrackedProject
}

func LoadNexus(root string) (*Nexus, error) {
	cfg, err := loadConfigOrDefault(root)
	if err != nil {
		return nil, err
	}
	base := strings.TrimSpace(cfg.ProjectsRootDir)
	if base == "" {
		return nil, fmt.Errorf("nexus mode requires projects_root_dir in .hazel/config.yaml")
	}
	if !filepath.IsAbs(base) {
		base = filepath.Join(root, base)
	}
	base = filepath.Clean(base)

	repos, err := discoverGitRepos(base)
	if err != nil {
		return nil, err
	}

	used := map[string]bool{}
	projects := make([]TrackedProject, 0, len(repos))
	for _, repo := range repos {
		key := makeProjectKey(repo, used)
		storageRoot := filepath.Join(hazelDir(root), "projects", key)
		if err := initProjectStorageRoot(storageRoot); err != nil {
			return nil, err
		}
		repoSlug := readRepoSlugFromGitConfig(repo)
		name := filepath.Base(repo)
		if repoSlug != "" {
			name = repoSlug
		}
		p := TrackedProject{
			Key:         key,
			Name:        name,
			RepoPath:    repo,
			StorageRoot: storageRoot,
			RepoSlug:    repoSlug,
		}
		if err := writeProjectMeta(storageRoot, ProjectMeta{
			Key:      key,
			Name:     name,
			RepoPath: repo,
			RepoSlug: repoSlug,
		}); err != nil {
			return nil, err
		}
		if err := ensureProjectWiki(p); err != nil {
			return nil, err
		}
		projects = append(projects, p)
	}

	sort.Slice(projects, func(i, j int) bool {
		if projects[i].Name != projects[j].Name {
			return projects[i].Name < projects[j].Name
		}
		return projects[i].Key < projects[j].Key
	})

	return &Nexus{Root: root, ProjectsRootDir: base, Projects: projects}, nil
}

func discoverGitRepos(base string) ([]string, error) {
	if !exists(base) {
		return nil, fmt.Errorf("projects_root_dir does not exist: %s", base)
	}
	ents, err := os.ReadDir(base)
	if err != nil {
		return nil, err
	}
	var repos []string
	for _, e := range ents {
		if !e.IsDir() {
			continue
		}
		candidate := filepath.Join(base, e.Name())
		if isGitRepoDir(candidate) {
			repos = append(repos, filepath.Clean(candidate))
		}
	}
	sort.Strings(repos)
	return repos, nil
}

func isGitRepoDir(path string) bool {
	_, err := os.Stat(filepath.Join(path, ".git"))
	return err == nil
}

func makeProjectKey(repo string, used map[string]bool) string {
	base := sanitizeProjectKey(filepath.Base(repo))
	if base == "" {
		base = "project"
	}
	if !used[base] {
		used[base] = true
		return base
	}
	h := sha1.Sum([]byte(repo))
	suffix := hex.EncodeToString(h[:])[:8]
	candidate := base + "-" + suffix
	used[candidate] = true
	return candidate
}

func sanitizeProjectKey(s string) string {
	s = strings.ToLower(strings.TrimSpace(s))
	var b strings.Builder
	lastDash := false
	for _, r := range s {
		ok := (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9')
		if ok {
			b.WriteRune(r)
			lastDash = false
			continue
		}
		if !lastDash {
			b.WriteByte('-')
			lastDash = true
		}
	}
	out := strings.Trim(b.String(), "-")
	return out
}

func initProjectStorageRoot(root string) error {
	if err := ensureDir(hazelDir(root)); err != nil {
		return err
	}
	for _, d := range []string{tasksDir(root), runsDir(root), archiveDir(root), filepath.Join(hazelDir(root), "export"), filepath.Join(hazelDir(root), "templates"), filepath.Join(root, "wiki")} {
		if err := ensureDir(d); err != nil {
			return err
		}
	}
	if !exists(boardPath(root)) {
		if err := writeYAMLFile(boardPath(root), &Board{Version: 1, Tasks: []*BoardTask{}}); err != nil {
			return err
		}
	}
	if !exists(configPath(root)) {
		cfg := defaultConfig()
		if err := writeYAMLFile(configPath(root), &cfg); err != nil {
			return err
		}
	}
	if !exists(filepath.Join(hazelDir(root), "templates", "task.md")) {
		if err := writeFileAtomic(filepath.Join(hazelDir(root), "templates", "task.md"), []byte(templateTaskMD), 0o644); err != nil {
			return err
		}
	}
	if !exists(filepath.Join(hazelDir(root), "templates", "impl.md")) {
		if err := writeFileAtomic(filepath.Join(hazelDir(root), "templates", "impl.md"), []byte(templateImplMD), 0o644); err != nil {
			return err
		}
	}
	return nil
}

func ensureProjectWiki(p TrackedProject) error {
	wikiDir := filepath.Join(p.StorageRoot, "wiki")
	if err := ensureDir(wikiDir); err != nil {
		return err
	}

	readmePath := filepath.Join(wikiDir, "README.md")
	if !exists(readmePath) {
		readmeBody := "# " + p.Name + "\n\n"
		readmeBody += "Local project wiki generated by Hazel Nexus.\n\n"
		readmeBody += "- Repo path: `" + p.RepoPath + "`\n"
		if p.RepoSlug != "" {
			readmeBody += "- Repo slug: `" + p.RepoSlug + "`\n"
		}
		readmeBody += "- Last initialized: " + time.Now().Format(time.RFC3339) + "\n"
		readmeBody += "\n## Notes\n\nUse this page for project-level wiki notes.\n\n"
		readmeBody += "The repository top-level README is mirrored to `SOURCE_README.md`.\n"
		if err := writeFileAtomic(readmePath, []byte(readmeBody), 0o644); err != nil {
			return err
		}
	}

	featuresBody := "# Features and Usage\n\n"
	featuresBody += "This page is a workspace-level summary scaffold. Fill in key flows as you discover them.\n\n"
	featuresBody += "## Core Features\n\n"
	featuresBody += "- Document the main capabilities of this repo here.\n\n"
	featuresBody += "## Usage Guides\n\n"
	featuresBody += "- Add setup commands\n"
	featuresBody += "- Add local development workflow\n"
	featuresBody += "- Add deployment/release workflow\n"
	featuresPath := filepath.Join(wikiDir, "FEATURES_AND_USAGE.md")
	if !exists(featuresPath) {
		if err := writeFileAtomic(featuresPath, []byte(featuresBody), 0o644); err != nil {
			return err
		}
	}

	sourceReadmePath := filepath.Join(wikiDir, "SOURCE_README.md")
	sourceReadme := filepath.Join(p.RepoPath, "README.md")
	sourceReadmeBody := "# Source README\n\n"
	sourceReadmeBody += "Synced from `" + sourceReadme + "`.\n\n"
	if b, err := os.ReadFile(sourceReadme); err == nil {
		sourceReadmeBody += string(b)
	} else {
		sourceReadmeBody += "No top-level README.md was found in the repository.\n"
	}
	if err := writeFileAtomic(sourceReadmePath, []byte(sourceReadmeBody), 0o644); err != nil {
		return err
	}

	changelogBody := "# Changelog\n\n"
	changelogBody += "Recent commits (newest first).\n\n"
	if lines, err := gitCommitChangelog(p.RepoPath, 80); err == nil {
		changelogBody += strings.Join(lines, "\n") + "\n"
	} else {
		changelogBody += "Unable to read git history: " + err.Error() + "\n"
	}
	if err := writeFileAtomic(filepath.Join(wikiDir, "CHANGELOG.md"), []byte(changelogBody), 0o644); err != nil {
		return err
	}
	return nil
}

func gitCommitChangelog(repo string, limit int) ([]string, error) {
	cmd := exec.Command("git", "-C", repo, "log", fmt.Sprintf("-n%d", limit), "--date=short", "--pretty=format:* %ad | `%h` | %s (%an)")
	b, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	raw := strings.TrimSpace(string(b))
	if raw == "" {
		return []string{"- No commits found."}, nil
	}
	return strings.Split(raw, "\n"), nil
}

func (n *Nexus) ProjectByKey(key string) (TrackedProject, bool) {
	for _, p := range n.Projects {
		if p.Key == key {
			return p, true
		}
	}
	return TrackedProject{}, false
}

func SyncWiki(root string, projectKey string) (int, error) {
	nx, err := LoadNexus(root)
	if err != nil {
		return 0, err
	}
	if nx == nil {
		return 0, fmt.Errorf("projects_root_dir is not configured")
	}
	count := 0
	for _, p := range nx.Projects {
		if projectKey != "" && p.Key != projectKey {
			continue
		}
		if err := ensureProjectWiki(p); err != nil {
			return count, err
		}
		count++
	}
	if projectKey != "" && count == 0 {
		return 0, fmt.Errorf("project not found: %s", projectKey)
	}
	return count, nil
}
